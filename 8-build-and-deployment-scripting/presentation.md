## Continuous Delivery: Build and Deployment Scripting
#### Build Tools, <span style="color: blue">Monorepo vs Polyrepo</span>, Principles and Practices, <span style="color: blue">Package Managers</span>, <span style="color: blue">Code Generation</span>, <span style="color: blue">Sample Project Structure (Changelogs, Docs, Tests, Assets, Examples, Dependencies, Version, Pipelines, Linting, Formatting, Type-checking, Code Generation)</span>, Deployment Scripting, Tips and Tricks, <span style="color: blue">Infrastructure as a Code (Terraform, Ansible)</span>

<img src="assets/iaac.png" style="max-width: 550px"/>

<small><strong>Lecturer:</strong> Alireza Roshanzamir</small>

<small><strong>Keywords:</strong> Continuous Delivery, Continuous Integration, DevOps, Build, Test, Release, Deployment, Automation, Version Control, Deployment Pipeline</small>

<small><small> Tir 1402/August 2023</small></small>

---
## Introduction
It is vital to script building, testing, and packaging applications when working on large or distributed teams (including open source projects), since otherwise, it can take days to get a new team member up and running.

Every modern platform has a way to run the build from the command line. Rails projects can run the default Rake task; .NET projects can use MsBuild; Java projects (if set up correctly) can use Ant, Maven, Buildr, or Gradle; and with CMake or SCons, not much is required to get a simple C/C++ project going. Just have your CI server run this command to create binaries and run tests.

However, once your project gets more complex-you have multiple components, or unusual packaging needs-you'll need to roll up your
sleeves and dive into build scripting.

Deploying software into testing and production environments is rarely as simple as dropping a single binary ﬁle and requires a series of steps such as conﬁguring your application, initializing data, conﬁguring the infrastructure, operating systems, and middleware, setting up mock external systems, and so on.

This session aims to give you an overview of the principles common to all build and deployment tools, information to get you going, some tips and tricks, and pointers to more information.

---
## An Overview of Build Tools
All build tools have a common core: They allow you to model a dependency network:

<img src="assets/build-dependency-network.png">

Build tool types:
- Task-oriented
  - Describe the dependency network in terms of a set of tasks
  - Such as Ant, NAnt, MSBuild
  - Keep no state between builds, so, less powerful and entirely unsuitable for compiling C++
  - Work ﬁne for languages such as C# since the compilers for these languages have built-in logic for performing incremental builds
- Product-oriented
  - Describe things in terms of the products they generate
  - Such as Make (also supports _phony targets_ such as clean, install, and test), Bazel, and Pants (Bazel and Pants are relatively mixed)
  - Keep their state in the form of timestamps on the ﬁles generated by each of the tasks
- Mixed
  - Such as Rake

<details>
<summary>Note</summary>
Mention the _cookie targets_ in Make.
</details>

------
### An Overview of Build Tools: Make
Powerful product-oriented build tool capable of tracking dependencies within a build and building only those components that are affected by a particular change.

But, it's hard to debug complex Makefiles. A common convention adopted by teams working on large codebases is to create a Makeﬁle for each directory, and have a top-level Makeﬁle that recursively runs the Makeﬁles in each subdirectory:

<img src="assets/recursive-makefile.png">

which is [considered harmful](https://accu.org/journals/overload/14/71/miller_2004/).

Some other drawbacks:
- OS specific (it depends on the shell)
- Whitespace can be signiﬁcant under certain circumstances
- Doesn't provide for extensions to the core system

------
### An Overview of Build Tools: Ant
The runtime components of Ant are written in Java, but the Ant scripts are an external DSL written in XML. This combination gives Ant powerful cross-platform capabilities.

Some shortcomings:
- XML is neither succinct nor pleasant for humans to read.
- There are no real domain concepts over and above a task.
- You cannot easily ask questions about Ant tasks, such as "How many tests ran?" and "How long did they take?".
- While supports reuse through the import and macrodef tasks, these are poorly understood by novice users.

As a result of these limitations, Ant ﬁles tend to be long and poorly factored-it is not unusual for Ant ﬁles to be thousands of lines long.

------
### An Overview of Build Tools: NAnt and MSBuild
NAnt uses essentially the same syntax as Ant, with only a few differences. Microsoft later introduced its minor variation on NAnt and called it MSBuild which is more tightly integrated into Visual Studio, understanding how to build Visual Studio solutions and projects and
how to manage dependencies.

------
### An Overview of Build Tools: Maven
Maven attempts to remove a large amount of boilerplate found in Ant ﬁles by having a more complex domain that makes many assumptions about the way your Java project is laid out. This principle of favoring convention over conﬁguration means that, so long as your project conforms to the structure dictated by Maven, it will perform almost any build, deploy, test, and release task you can imagine with a single command, without having to write more than a few lines of XML:

<img src="assets/maven-project-structure.webp">

Some shortcomings:
- If your project doesn't conform to Maven's assumptions about structure and lifecycle, it can be hard to make Maven do what you want (this could be considered a feature).
- To extend it, you need to write code. However, it has plugins for almost everything you'd want to do.

------
### An Overview of Build Tools: Rake
The dominant Ruby build tool, Rake, came about as an experiment to see if Make's functionality could be easily reproduced by creating an **internal DSL** in Ruby. Rake has no understanding of anything except tasks and dependencies. However, since Rake scripts are plain Ruby, you can use Ruby's API to carry out whatever tasks you want. You have all the native power of a general-purpose programming language at your disposal.

You can refactor and modularize your builds, and you can use your regular development environment. It is straightforward to debug Rake using the standard Ruby debugger.

Some disadvantages:
- You have to ensure that a decent runtime is available on your platform
- you have to interact with RubyGems

------
### An Overview of Build Tools: Buildr
The new generation of build tools, such as Buildr, Gradle, and Gantt, have taken the approach of using real programming languages for build scripts.

Buildr is built on top of Rake, so everything you can do in Rake you can continue to do in Buildr. However, Buildr is also a drop-in replacement for Maven-it uses the same conventions that Maven does, including ﬁlesystem layout, artifact speciﬁcations, and repositories. It also lets you use Ant tasks (including any custom ones) with zero conﬁguration.

If you're starting a new Java project, or looking for a replacement for Ant or Maven, we strongly suggest you consider Buildr, or Gradle if you prefer your DSLs in Groovy.

------
### An Overview of Build Tools: Psake
Psake is an internal DSL written in PowerShell, which provides task-oriented dependency networks.

------
### An Overview of Build Tools: Pants
TODO: Should be completed.

------
### An Overview of Build Tools: Bazel, Buck, Pants
TODO: Should be completed.

---
## Monorepo vs Polyrepo
TODO: Should be completed.

---
## Principles and Practices
Some general principles and practices of build and deployment scripting should apply to whichever technology you use:
- Create a Script for Each Stage in Your Deployment Pipeline
  - Do not have a single script for whole deployment pipeline
- Use an Appropriate Technology to Deploy Your Application
  - Use the right tool for the job when automating deployment, not a general-purpose scripting language. For example, for WebSphere Application Server, you can use the Wsadmin tool.
- Use the Same Scripts to Deploy to Every Environment
  - If your application is complex in terms of its deployment architecture, you will have to make some simpliﬁcations to get it working on developer machines.
- Use Your Operating System's Packaging Tools [forDeployment]
  - For example, Debian and Ubuntu both use the Debian package system; RedHat, SuSE, and many other ﬂavors of Linux use the RedHat package system; Windows users can use the Microsoft Installer system, and so forth.
  - Commercial middleware servers, for example, often require special tools to perform deployments. In this case, a hybrid approach is necessary.
  - You can also use platform-speciﬁc packaging systems, such as Ruby Gems, Python Eggs/Wheels, Perl's CPAN, and so on, to distribute your application, but they are designed by and for developers, not system administrators.
- Ensure the Deployment Process Is Idempotent
  - Leave the target environment in the same (correct) state, regardless of the state it ﬁnds it in when starting a deployment.
  - If you cannot do this, validate the assumptions your deployment process makes about the environment, and fail the deployment if they are not met.
  - Tools such as Puppet analyzes the conﬁguration of the target environment and makes only the necessary changes to bring it in sync with the declarative speciﬁcation of the desired state of the environment
- Evolve Your Deployment System Incrementally
  - You don't have to have completed all of the steps at once. The ﬁrst time you write a script to deploy the application in a local development environment and share it with the team, you have saved lots of work for individual developers.
  - Then, move on to reﬁning these scripts so they can be used in the acceptance test environment to deploy and run the application so that the tests can be run.

---
## Package Managers
Some language specific and language agnostic package managers:

<img src="assets/language-specific-vs-language-agnostic-package-managers.png">

<details>
  <summary>Note:</summary>
  Mention the following clues:
  <ul>
    <li>Language agnositc package manager doesn't result language agnostic package</li>
    <li>Virtual environment and local packages directory</li>
    <li>Built distribution vs source distribution (you may need different systems for generating built distributions)</li>
    <li>Use "distribution package" instead of "package" when searching</li>
    <li>Package dependency inclusion level (wheel, PEX, RPM/Deb, PyInstaller, Conda, Docker)</li>
    <li>Language Specific vs Language Agnostic Package Managers</li>
    <li>OS-Dependent vs OS-Independent Package Managers</li>
    <li>Dependency Pinning (presented in detail in the next sessions)</li>
    <li>Single Project Multiple Version Support</li>
  </ul>
</details>

---
## Sample Project Structure
TODO: Should be completed.

---
## Deployment Scripting
Changes to testing and production environments should only be made through an automated process.

In addition to the previous mentioned notes, the following should be considered:
- Deploying and Testing Layers
  - You should always strive to build on foundations that are known to be good. Before we even bother to copy our binary deliverables to the correct place in the ﬁlesystem, we want to know that our environment is ready for us in these layers:
    <img src="assets/deploying-software-layers.png">
- Testing Your Environment's Conﬁguration
  - The objective is to provide a degree of conﬁdence that the layer that has just been deployed is working:
    <img src="assets/deployment-testing-layers.png">

<details>
<summary>Note</summary>
Mention the "Smoke-Testing N-Tier Architecture" through simple HTTP requests and displaying the results.
</details>

---
## Tips and Tricks
- Always Use Relative Paths
  - Absolute paths create a tight dependency between the conﬁguration of a speciﬁc machine and your build process.
  - Try to minimize absolute paths by making all of the paths in your system relative to one or more well-deﬁned root paths-the deployment root, the conﬁguration root, and so on-and overriding just these roots.
- Eliminate Manual Steps
  - For many organizations, a "build script" is a printed document with a series of instructions like:

    ```
    ...
    STEP 14. Copy all the dlls from the CDROM directory E:\web_server\dlls\ into   the   new
    virtual directory
    STEP 15. Open a command prompt and type: regsvr webserver_main.dll
    STEP 16. Open the Microsoft IIS Management console and click Create New   Application
    ...
    ```
  - "When you have to do it a second time." The third time you do something, it should be done using an automated process.
- Build In Traceability from Binaries to Version Control
  - Some packages such a JAR files can include metadata.
  - You can use simple MD5 hashing.
- Don't Check Binaries into Version Control as Part of Your Build
  - The rule of thumb is not to check in anything created as part of your build, test, and deploy cycle into source control.
- Test Targets Should Not Fail the Build
  - Make the failure set a ﬂag but fail the build later, after generating more useful reports or running a more complete set of tests.
- Constrain Your Application with Integrated Smoke Tests
  - Make sure the deployed version validates its conﬁguration when it is installed.

---
## Summary